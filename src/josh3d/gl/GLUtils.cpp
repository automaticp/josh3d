#include "GLProgram.hpp"
#include "GLShaders.hpp"
#include <glbinding/gl/gl.h>
#include <glbinding/gl/types.h>
#include <glbinding/glbinding.h>
#include <glbinding/AbstractFunction.h>
#include <glbinding/Binding.h>
#include <glbinding/Function.h>
#include <glbinding/FunctionCall.h>
#include <glbinding-aux/debug.h>
#include <glbinding-aux/Meta.h>
#include <glbinding-aux/types_to_string.h>
#include <sstream>
#include <string>
#include <vector>
#include <iostream>


using namespace gl;
using namespace glbinding;


namespace josh {


/*
    The glbinding invokes the callbacks
    in the following order (if defined):
    - Global Before Callback
    - Function Before Callback
    - Global After Callback
    - Function After Callback
    - Global Logging Callback

    Thus, we use the Global After Callback to check for errors,
    and Function After Callback to selectively log some function calls.
*/


namespace {


auto get_generic_call_info(const glbinding::FunctionCall& call)
    -> std::string
{
    std::stringstream ss;
    ss << call.function->name() << '(';
    for (size_t i{ 0 }; i < call.parameters.size(); ++i) {
        ss << call.parameters[i].get();
        if ((i + 1) < call.parameters.size()) {
            ss << ", ";
        }
    }
    ss << ')';
    if (call.returnValue) {
        ss << " -> " << call.returnValue.get();
    }
    return std::move(ss).str();
};


// This enables "after" callbacks. Just terser.
auto mask(auto& fun)
    -> decltype(fun)&
{
    fun.addCallbackMask(CallbackMask::After);
    return fun;
}


} // namespace




void log_gl_errors(std::ostream& os) {

    auto log_if_error = [&os](const FunctionCall& call) {
        const GLenum error = glGetError();

        if (error != GL_NO_ERROR) {
		    os << "[OpenGL ERROR]: " << error << '\n';
            os << "[GENERATED BY]: " << get_generic_call_info(call) << '\n';
		}
    };

    glbinding::setCallbackMaskExcept(
		CallbackMask::After | CallbackMask::ParametersAndReturnValue,
		{ "glGetError" }
	);

	glbinding::setAfterCallback(log_if_error);
}




void log_gl_shader_creation(std::ostream& os) {
    using Binding = glbinding::Binding;

    auto log_shader_compile_status = [](std::ostream& os, GLuint id) {
        // It's not necessarily a vertex shader, we just want to access the shader API.
        // TODO: Surely this would not be needed if we had an AnyShader type instead.
        auto shader = RawVertexShader<GLConst>::from_id(id);

        os << "[COMPILE STATUS]: " << (shader.has_compiled_successfully() ? "OK" : "FAIL") << ", ";
        os << "ID: " << id << ", ";

        GLenum type;
        glGetShaderiv(id, GL_SHADER_TYPE, &type);
        os << type << '\n';

        const std::string info_log = shader.get_info_log();
        if (!info_log.empty()) {
            os << "[COMPILE LOG]: " << info_log << '\n';
        }
    };

    mask(Binding::CompileShader).setAfterCallback([&](GLuint id) {
        log_shader_compile_status(os, id);
    });


    auto log_program_link_status = [](std::ostream& os, GLuint id) {
        auto program = RawProgram<GLConst>::from_id(id);

        os << "[LINK STATUS]: " << (program.has_linked_successfully() ? "OK" : "FAIL") << ", ";
        os << "ID: " << id << ", ";
        os << program.get_num_attached_shaders() << " Shader(s)\n";

        const std::string info_log = program.get_info_log();
        if (!info_log.empty()) {
            os << "[LINK LOG]: " << info_log << '\n';
        }
    };

    mask(Binding::LinkProgram).setAfterCallback([&](GLuint id) {
        log_program_link_status(os, id);
    });

}




} // namespace josh
