#include "Logging.hpp"
#include <glbinding/gl/gl.h>
#include <glbinding/gl/types.h>
#include <glbinding/glbinding.h>
#include <glbinding/AbstractFunction.h>
#include <glbinding/Binding.h>
#include <glbinding/Function.h>
#include <glbinding/FunctionCall.h>
#include <glbinding-aux/debug.h>
#include <glbinding-aux/Meta.h>
#include <glbinding-aux/types_to_string.h>
#include <sstream>
#include <vector>
#include <iostream>


namespace josh {


namespace globals {
std::ostream& logstream = std::clog;
} // namespace globals


namespace {


auto get_generic_call_info(const glbinding::FunctionCall& call)
    -> std::string
{
    std::stringstream ss;
    ss << call.function->name() << '(';
    for (size_t i{ 0 }; i < call.parameters.size(); ++i) {
        ss << call.parameters[i].get();
        if ((i + 1) < call.parameters.size()) {
            ss << ", ";
        }
    }
    ss << ')';
    if (call.returnValue) {
        ss << " -> " << call.returnValue.get();
    }
    return std::move(ss).str();
};


} // namespace




void enable_glbinding_logger(std::ostream& os) {

    using namespace gl;
    using namespace glbinding;

    /*
        The glbinding invokes the callbacks
        in the following order (if defined):
        - Global Before Callback
        - Function Before Callback
        - Global After Callback
        - Function After Callback
        - Global Logging Callback

        Thus, we use the Global After Callback to check for errors,
        and Function After Callback to selectively log some function calls.
    */


    // Global Error Checking

    auto log_if_error = [&os](const FunctionCall& call) {
        const GLenum error = glGetError();

        if (error != GL_NO_ERROR) {
		    os << "[OpenGL Error] " << error << '\n';
            os << "[Generated By] " << get_generic_call_info(call) << '\n';
		}
    };

    glbinding::setCallbackMaskExcept(
		CallbackMask::After | CallbackMask::ParametersAndReturnValue,
		{ "glGetError" }
	);
	glbinding::setAfterCallback(log_if_error);


    // Per-Function Logging

    using glbinding::aux::Meta;

    auto mask = [](auto& fun) -> decltype(fun)& { fun.addCallbackMask(CallbackMask::After); return fun; };

    mask(Binding::GenTextures).setAfterCallback([&os](GLsizei n, GLuint* id) {
        os << "glGenTextures(" << n << ", &" << *id << ")\n";
    });

    mask(Binding::DeleteTextures).setAfterCallback([&os](GLsizei n, const GLuint* id) {
        os << "glDeleteTextures(" << n << ", &" << *id << ")\n";
    });


    mask(Binding::GenVertexArrays).setAfterCallback([&os](GLsizei n, GLuint* id) {
        os << "glGenVertexArrays(" << n << ", &" << *id << ")\n";
    });

    mask(Binding::DeleteVertexArrays).setAfterCallback([&os](GLsizei n, const GLuint* id) {
        os << "glDeleteVertexArrays(" << n << ", &" << *id << ")\n";
    });

    mask(Binding::GenBuffers).setAfterCallback([&](GLsizei n, GLuint* id) {
        os << "glGenBuffers(" << n << ", &" << *id << ")\n";
    });

    mask(Binding::DeleteBuffers).setAfterCallback([&](GLsizei n, const GLuint* id) {
        os << "glDeleteBuffers(" << n << ", &" << *id << ")\n";
    });

    mask(Binding::BufferData).setAfterCallback([&](GLenum type, GLsizeiptr size, const void* data, GLenum usage) {
        os << "glBufferData(" << Meta::getString(type) << ", " << size << ", " << data << ", " << Meta::getString(usage) << ")\n";
    });



    mask(Binding::CreateShader).setAfterCallback([&os](GLuint return_id, GLenum type) {
        os << "glCreateShader(" << Meta::getString(type) << ") -> " << return_id << '\n';
    });

    mask(Binding::DeleteShader).setAfterCallback([&os](GLuint id) {
        os << "glDeleteShader(" << id << ")\n";
    });


    auto log_shader_compile_status = [](std::ostream& os, GLuint id) {
        // TODO: Moving this to, or above "gl" would surely make this easier,
        // since then we can depend on all the function wrappers.
        os << "[Compile Status] ";
        GLboolean status;
        glGetShaderiv(id, GL_COMPILE_STATUS, &status);
        os << ((status == GL_TRUE) ? "SUCCESS" : "FAILURE") << ", ";
        GLenum type;
        glGetShaderiv(id, GL_SHADER_TYPE, &type);
        os << type << ", ";
        GLsizei length;
        glGetShaderiv(id, GL_SHADER_SOURCE_LENGTH, &length);
        os << "GL_SHADER_SOURCE_LENGTH: " << length;
        os << '\n';

        GLsizei log_length;
        glGetShaderiv(id, GL_INFO_LOG_LENGTH, &log_length);
        if (log_length) {
            auto info_log = std::make_unique<GLchar[]>(static_cast<size_t>(log_length));
            glGetShaderInfoLog(id, log_length, nullptr, info_log.get());
            os << "[Compilation Log] " << info_log.get() << '\n';
        }
    };

    mask(Binding::CompileShader).setAfterCallback([&](GLuint id) {
        os << "glCompileShader(" << id << ")\n";
        log_shader_compile_status(os, id);
    });



    mask(Binding::CreateProgram).setAfterCallback([&os](GLuint return_id) {
        os << "glCreateProgram() -> " << return_id << '\n';
    });

    mask(Binding::DeleteProgram).setAfterCallback([&os](GLuint id) {
        os << "glDeleteProgram(" << id << ")\n";
    });

    mask(Binding::AttachShader).setAfterCallback([&](GLuint program_id, GLuint shader_id) {
        os << "glAttachShader(" << program_id << ", " << shader_id << ")\n";
    });


    auto log_program_link_status = [](std::ostream& os, GLuint id) {
        os << "[Link Status] ";
        GLboolean status;
        glGetProgramiv(id, GL_LINK_STATUS, &status);
        os << ((status == GL_TRUE) ? "SUCCESS" : "FAILURE") << ", ";
        GLsizei num_shaders;
        glGetProgramiv(id, GL_ATTACHED_SHADERS, &num_shaders);
        os << "GL_ATTACHED_SHADERS: " << num_shaders;
        os << '\n';

        GLsizei log_length;
        glGetProgramiv(id, GL_INFO_LOG_LENGTH, &log_length);
        if (log_length) {
            auto info_log = std::make_unique<GLchar[]>(static_cast<size_t>(log_length));
            glGetProgramInfoLog(id, log_length, nullptr, info_log.get());
            os << "[Linking Log] " << info_log.get() << '\n';
        }
    };

    mask(Binding::LinkProgram).setAfterCallback([&](GLuint id) {
        os << "glLinkProgram(" << id << ")\n";
        log_program_link_status(os, id);
    });

}




} // namespace josh
