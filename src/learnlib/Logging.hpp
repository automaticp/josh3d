#pragma once
#include <iostream>
#include <string_view>
#include <sstream>
#include <vector>
#include <functional>
#include <glbinding/gl/gl.h>
#include <glbinding/glbinding.h>
#include <glbinding/AbstractFunction.h>
#include <glbinding/Binding.h>
#include <glbinding/Function.h>
#include <glbinding/FunctionCall.h>
#include <glbinding-aux/debug.h>
#include <glbinding-aux/Meta.h>


namespace learn {


inline std::ostream& global_logstream{ std::clog };


namespace detail {


inline std::stringstream get_generic_call_info(const glbinding::FunctionCall& call) {
    std::stringstream ss;
    ss << call.function->name() << '(';
    for ( size_t i{ 0 }; i < call.parameters.size(); ++i ) {
        ss << call.parameters[i].get();
        if ( (i + 1) < call.parameters.size() ) {
            ss << ", ";
        }
    }
    ss << ')';
    if ( call.returnValue ) {
        ss << " -> " << call.returnValue.get();
    }
    return ss;
};


inline std::string_view get_error_name(const gl::GLenum error) {
    using namespace gl;
    switch ( error ) {
        case GL_INVALID_ENUM: return "GL_INVALID_ENUM";
        case GL_INVALID_VALUE: return "GL_INVALID_VALUE";
        case GL_INVALID_OPERATION: return "GL_INVALID_OPERATION";
        case GL_INVALID_FRAMEBUFFER_OPERATION: return "GL_INVALID_FRAMEBUFFER_OPERATION";
        case GL_OUT_OF_MEMORY: return "GL_OUT_OF_MEMORY";
        case GL_STACK_UNDERFLOW: return "GL_STACK_UNDERFLOW";
        case GL_STACK_OVERFLOW: return "GL_STACK_OVERFLOW";
        default: return "Unknown Error";
    }
};


} // namespace detail





inline void enable_glbinding_logger(std::ostream& os = global_logstream) {

    using namespace gl;
    using namespace glbinding;

    /*
        The glbinding invokes the callbacks
        in the following order (if defined):
        - Global Before Callback
        - Function Before Callback
        - Global After Callback
        - Function After Callback
        - Global Logging Callback

        Thus, we use the Global After Callback to check for errors,
        and Function After Callback to selectively log some function calls.
    */


    // Global Error Checking

    auto log_if_error = [&os](const FunctionCall& call) {
        const GLenum error = glGetError();

        if ( error != GL_NO_ERROR ) {
		    os << "[OpenGL Error] " << detail::get_error_name(error) << '\n';
            os << "[Generated By] " << detail::get_generic_call_info(call).view() << '\n';
		}
    };

    glbinding::setCallbackMaskExcept(
		CallbackMask::After | CallbackMask::ParametersAndReturnValue,
		{ "glGetError" }
	);
	glbinding::setAfterCallback(log_if_error);


    // Per-Function Logging

    using glbinding::aux::Meta;

    auto mask = [](auto& fun) -> decltype(fun)& { fun.addCallbackMask(CallbackMask::After); return fun; };

    mask(Binding::GenTextures).setAfterCallback([&os](GLsizei n, GLuint* id) {
        os << "glGenTextures(" << n << ", &" << *id << ")\n";
    });

    mask(Binding::DeleteTextures).setAfterCallback([&os](GLsizei n, const GLuint* id) {
        os << "glDeleteTextures(" << n << ", &" << *id << ")\n";
    });


    mask(Binding::GenVertexArrays).setAfterCallback([&os](GLsizei n, GLuint* id) {
        os << "glGenVertexArrays(" << n << ", &" << *id << ")\n";
    });

    mask(Binding::DeleteVertexArrays).setAfterCallback([&os](GLsizei n, const GLuint* id) {
        os << "glDeleteVertexArrays(" << n << ", &" << *id << ")\n";
    });

    mask(Binding::GenBuffers).setAfterCallback([&](GLsizei n, GLuint* id) {
        os << "glGenBuffers(" << n << ", &" << *id << ")\n";
    });

    mask(Binding::DeleteBuffers).setAfterCallback([&](GLsizei n, const GLuint* id) {
        os << "glDeleteBuffers(" << n << ", &" << *id << ")\n";
    });

    mask(Binding::BufferData).setAfterCallback([&](GLenum type, GLsizeiptr size, const void* data, GLenum usage) {
        os << "glBufferData(" << Meta::getString(type) << ", " << size << ", " << data << ", " << Meta::getString(usage) << ")\n";
    });



    mask(Binding::CreateShader).setAfterCallback([&os](GLuint return_id, GLenum type) {
        os << "glCreateShader(" << Meta::getString(type) << ") -> " << return_id << '\n';
    });

    mask(Binding::DeleteShader).setAfterCallback([&os](GLuint id) {
        os << "glDeleteShader(" << id << ")\n";
    });


    auto log_shader_compile_status = [](std::ostream& os, GLuint id) {
        os << "[Compile Status] ";
        GLint val;
        glGetShaderiv(id, GL_COMPILE_STATUS, &val);
        os << "GL_COMPILE_STATUS: " << Meta::getString(val) << ", ";
        glGetShaderiv(id, GL_SHADER_TYPE, &val);
        os << "GL_SHADER_TYPE: " << Meta::getString(GLenum(val)) << ", ";
        glGetShaderiv(id, GL_SHADER_SOURCE_LENGTH, &val);
        os << "GL_SHADER_SOURCE_LENGTH: " << val;
        os << '\n';

        glGetShaderiv(id, GL_INFO_LOG_LENGTH, &val);
        if ( val ) {
            auto info_log = std::make_unique<GLchar[]>(static_cast<size_t>(val));
            glGetShaderInfoLog(id, val, nullptr, info_log.get());
            os << "[Compilation Log] " << info_log.get() << '\n';
        }
    };

    mask(Binding::CompileShader).setAfterCallback([&](GLuint id) {
        os << "glCompileShader(" << id << ")\n";
        log_shader_compile_status(os, id);
    });



    mask(Binding::CreateProgram).setAfterCallback([&os](GLuint return_id) {
        os << "glCreateProgram() -> " << return_id << '\n';
    });

    mask(Binding::DeleteProgram).setAfterCallback([&os](GLuint id) {
        os << "glDeleteProgram(" << id << ")\n";
    });

    mask(Binding::AttachShader).setAfterCallback([&](GLuint program_id, GLuint shader_id) {
        os << "glAttachShader(" << program_id << ", " << shader_id << ")\n";
    });


    auto log_program_link_status = [](std::ostream& os, GLuint id) {
        os << "[Link Status] ";
        GLint val;
        glGetProgramiv(id, GL_LINK_STATUS, &val);
        os << "GL_LINK_STATUS: " << Meta::getString(val) << ", ";
        glGetProgramiv(id, GL_ATTACHED_SHADERS, &val);
        os << "GL_ATTACHED_SHADERS: " << val;
        os << '\n';

        glGetProgramiv(id, GL_INFO_LOG_LENGTH, &val);
        if ( val ) {
            auto info_log = std::make_unique<GLchar[]>(static_cast<size_t>(val));
            glGetShaderInfoLog(id, val, nullptr, info_log.get());
            os << "[Linking Log] " << info_log.get() << '\n';
        }
    };

    mask(Binding::LinkProgram).setAfterCallback([&](GLuint id) {
        os << "glLinkProgram(" << id << ")\n";
        log_program_link_status(os, id);
    });

}


} // namespace learn
