#version 430 core

#define LOCAL_SIZE_X 8
#define LOCAL_SIZE_Y 8

layout (local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y, local_size_z = 1) in;

const uint flat_local_size = gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z;

shared float local_value_samples[flat_local_size];

uniform sampler2D screen_color;

layout (std430, binding = 0) restrict writeonly buffer output_block {
    float color_values[];
};


float color_value(vec3 color) {
    return dot(color, vec3(0.2126, 0.7152, 0.0722));
}


// This is slightly better then my previous attempt.
// Now we sample a local_size_x * local_size_y rectangle
// for each work group and make one of the invocations
// reduce (compute the mean of) the samples.
//
// I'm still using a simple sampler2D and texture()
// and not image2D as it saves me the headache of
// correctly rounding the texel indices.
// I'm not trying to be super accurate, and the
// floating point [0, 1] texture coordinate space is
// really nice to work with when the number of texels is
// not a multiple of the local size.
//
// The XY sampling uniformity with respect to aspect ratio
// should probably be accounted for by the number of work groups
// at the dispatch call.
void main() {
    // Find our tex_coord position for this invocation.
    const vec2 group_step_size = 1.0 / gl_NumWorkGroups.xy;
    const vec2 group_tex_coords = gl_WorkGroupID.xy * group_step_size;

    const vec2 local_step_size = group_step_size / gl_WorkGroupSize.xy;
    const vec2 tex_coords = group_tex_coords + local_step_size * gl_LocalInvocationID.xy;

    // Make a local independent sample and write to the shared buffer.
    local_value_samples[gl_LocalInvocationIndex] =
        color_value(texture(screen_color, tex_coords).xyz);

    // Run parallel reduction on the shared samples.
    uint active_threads = flat_local_size;

    while (active_threads > 1) {

        active_threads /= 2;

        // Synchronize execution because abstract machine requires this.
        // Do not put the barrier under a non dynamically uniform condition
        // as the one below, or things might explode.
        barrier();

        if (gl_LocalInvocationIndex < active_threads) {
            memoryBarrierShared();
            local_value_samples[gl_LocalInvocationIndex] +=
                local_value_samples[gl_LocalInvocationIndex + active_threads];
        }

    }


    if (gl_LocalInvocationIndex == 0) {
        const uint group_index =
            gl_WorkGroupID.z * gl_NumWorkGroups.x * gl_NumWorkGroups.y +
            gl_WorkGroupID.y * gl_NumWorkGroups.x +
            gl_WorkGroupID.x;

        color_values[group_index] = local_value_samples[0] / local_value_samples.length();
    }
}

