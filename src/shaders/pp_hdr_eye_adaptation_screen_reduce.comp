#version 430 core

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;


// uniform layout (rgba16f, binding = 0) restrict readonly image2D screen_color;

uniform sampler2D screen_color;

layout (std430, binding = 0) restrict writeonly buffer output_block {
    float color_values[];
};


float color_value(vec3 color) {
    return dot(color, vec3(0.2126, 0.7152, 0.0722));
}

// So this is really bad but it is okay as a first step.
// We just sample the screen at equally spaced points and write pixel
// values at those points into the output buffer. Aspect ratio be damned.
//
// As you can probably guess, this is not a reduction, but rather is
// a sampling operation, but close enough for large sample sizes.
//
// Either way, I'm obviously redoing this to do proper reduction
// once I figure out what is local size and how tf to reduce in chunks.
void main() {
    // In terms of work groups. Will break if any local_size > 1.
    vec2 step_size = 1.0 / gl_NumWorkGroups.xy;
    vec2 tex_coords = gl_WorkGroupID.xy * step_size;

    const uvec3 id = gl_WorkGroupID;
    const uvec3 num_groups = gl_NumWorkGroups;

/*
gl_LocalInvocationIndex =
          gl_LocalInvocationID.z * gl_WorkGroupSize.x * gl_WorkGroupSize.y +
          gl_LocalInvocationID.y * gl_WorkGroupSize.x +
          gl_LocalInvocationID.x;
*/

    uint global_id =
        id.z * num_groups.x * num_groups.y +
        id.y * num_groups.x +
        id.x;

    color_values[global_id] = color_value(texture(screen_color, tex_coords).xyz);
}
