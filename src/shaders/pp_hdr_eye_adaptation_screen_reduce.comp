#version 430 core

#define LOCAL_SIZE_X 8
#define LOCAL_SIZE_Y 8

layout (local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y, local_size_z = 1) in;

const uint flat_local_size = gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z;

shared float local_value_samples[flat_local_size];

uniform sampler2D screen_color;

layout (std430, binding = 0) restrict writeonly buffer output_block {
    float color_values[];
};


float color_value(vec3 color) {
    return dot(color, vec3(0.2126, 0.7152, 0.0722));
}


float compute_mean_of_local_values();

// This is slightly better then my previous attempt.
// Now we sample a local_size_x * local_size_y rectangle
// for each work group and make one of the invocations
// reduce (compute the mean of) the samples.
//
// I'm still using a simple sampler2D and texture()
// and not image2D as it saves me the headache of
// correctly rounding the texel indices.
// I'm not trying to be super accurate, and the
// floating point [0, 1] texture coordinate space is
// really nice to work with when the number of texels is
// not a multiple of the local size.
//
// The XY sampling uniformity with respect to aspect ratio
// should probably be accounted for by the number of work groups
// at the dispatch call.
void main() {
    // Find our tex_coord position for this invocation.
    const vec2 group_step_size = 1.0 / gl_NumWorkGroups.xy;
    const vec2 group_tex_coords = gl_WorkGroupID.xy * group_step_size;

    const vec2 local_step_size = group_step_size / gl_WorkGroupSize.xy;
    const vec2 tex_coords = group_tex_coords + local_step_size * gl_LocalInvocationID.xy;

    // Make a local independent sample and write to the shared buffer.
    local_value_samples[gl_LocalInvocationIndex] =
        color_value(texture(screen_color, tex_coords).xyz);

    // Synchronize execution because abstract machine requires this.
    barrier();

    // Branch one of the invocations to do the final reduction.
    if (gl_LocalInvocationIndex == 0) {
        const uint group_index =
            gl_WorkGroupID.z * gl_NumWorkGroups.x * gl_NumWorkGroups.y +
            gl_WorkGroupID.y * gl_NumWorkGroups.x +
            gl_WorkGroupID.x;

        memoryBarrierShared();

        color_values[group_index] = compute_mean_of_local_values();
    }
}


float compute_mean_of_local_values() {
    float sum = 0.0;
    for (int i = 0; i < local_value_samples.length(); ++i) {
        sum += local_value_samples[i];
    }
    return sum / local_value_samples.length();
}
